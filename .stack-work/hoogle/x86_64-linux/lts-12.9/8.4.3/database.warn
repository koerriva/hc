Cabal:3686:failed to parse: }
base:2569:failed to parse: data a (:~:) b
base:2579:failed to parse: class a ~# b => (~~) (a :: k0) (b :: k1)
base:2584:failed to parse: data (a :: k1) (:~~:) (b :: k2)
base:2632:failed to parse: instance forall k (a :: k) (b :: k). (a ~ b) => a ~ b
base:5684:failed to parse: }
base:5704:failed to parse: }
base:6492:failed to parse: data a (:~:) b
base:6498:failed to parse: data (a :: k1) (:~~:) (b :: k2)
base:6633:failed to parse: data a (:~:) b
base:6639:failed to parse: data (a :: k1) (:~~:) (b :: k2)
base:11352:failed to parse: type HasCallStack = (?callStack :: CallStack)
base:19313:failed to parse: type Type = *
base:19319:failed to parse: type * = *
base:19322:failed to parse: type ★ = *
base:23110:failed to parse: data State# (a :: *) :: TYPE TupleRep ([] :: [RuntimeRep])
base:23112:failed to parse: data (~#) :: forall k0 k1. () => k0 -> k1 -> TYPE TupleRep ([] :: [RuntimeRep])
base:23116:failed to parse: data Void# :: TYPE TupleRep ([] :: [RuntimeRep])
base:23136:failed to parse: data Proxy# :: forall k0. () => k0 -> TYPE TupleRep ([] :: [RuntimeRep])
base:26482:failed to parse: class a ~# b => (~~) (a :: k0) (b :: k1)
base:26607:failed to parse: }
ghc:284:failed to parse: }
ghc:304:failed to parse: }
ghc:1324:failed to parse: type HasCallStack = ?callStack :: CallStack
ghc:7664:failed to parse: type AnnPayload = Serialized  The "payload" of an annotation allows recovery of its value at a given type, and can be persisted to an interface file
ghc:16816:failed to parse: }
ghc:24520:failed to parse: type LImportDecl name = Located (ImportDecl name)  When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi'
ghc:24584:failed to parse: type LIE name = Located (IE name)  When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma'
ghc:24811:failed to parse: type LHsType pass = Located (HsType pass)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list
ghc:24975:failed to parse: type LConDeclField pass = Located (ConDeclField pass)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list
ghc:26744:failed to parse: type LHsDecl id = Located (HsDecl id)  When in a list this may have  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi'
ghc:26778:failed to parse: type HsDeriving pass = Located [LHsDerivingClause pass]  The optional @deriving@ clauses of a data declaration. "Clauses" is plural because one can specify multiple deriving clauses using the @-XDerivingStrategies@ language extension.  The list of 'LHsDerivingClause's corresponds to exactly what the user requested to derive, in order. If no deriving clauses were specified, the list is empty.
ghc:27041:failed to parse: type FamInstEqn pass rhs = HsImplicitBndrs pass (FamEqn pass (HsTyPats pass) rhs)  Here, the @pats@ are type patterns (with kind and type bndrs). See Note [Family instance declaration binders]
ghc:27069:failed to parse: type LTyFamInstEqn pass = Located (TyFamInstEqn pass)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi' when in a list
ghc:27292:failed to parse: type LConDecl pass = Located (ConDecl pass)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnSemi' when in a GADT constructor list
ghc:27500:failed to parse: type LHsExpr p = Located (HsExpr p)  May have 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnComma' when in a list
ghc-prim:225:failed to parse: type * = TYPE  'LiftedRep
ghc-prim:228:failed to parse: type ★ = TYPE  'LiftedRep
mtl:693:failed to parse: newtype ReaderT r (m :: k -> *) (a :: k) :: forall k. () => * -> k -> * -> k -> *
mtl:1036:failed to parse: newtype ContT (r :: k) (m :: k -> *) a :: forall k. () => k -> k -> * -> * -> *
template-haskell:1081:failed to parse: type Cxt = [Pred]  @(Eq a, Ord b)@
template-haskell:4338:failed to parse: type Cxt = [Pred]  @(Eq a, Ord b)@
